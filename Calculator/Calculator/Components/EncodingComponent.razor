@using Calculator.Classes;
@using Calculator.Models;
@{
	<div class="encoding">
		<div class="child">
			<p>
				<label>
					Input Values:
					<input @bind="inputValuePair" />
				</label>
			</p>
		</div>
		<button class="button-purple" @onclick="Add">Add Value Pair</button>
		<button class="button-purple" @onclick="RemoveLastPair">Remove Value Pair</button>
	</div>
	<button class="button-purple" @onclick="Reset">Reset</button>
	<button class="button-purple" @onclick="Solve" disabled="@(valuePairs.Count == 0)">Solve</button>
	<div>
		<table>
			<tr>
				<th>Wert</th>
				<th>Anzahl</th>
			</tr>
			@foreach (Tuple<string, int> pair in valuePairs)
			{
				<tr>
					<td>@pair.Item1</td>
					<td>@pair.Item2</td>
				</tr>
			}
		</table>
	</div>
	<br />
	if (solved)
	{
		<div>
			<div>
				<table>
					<tr>
						<th>Wert</th>
						<th>Wahrscheinlichkeit</th>
						<th>Encoding</th>
					</tr>
					@foreach (var result in encodingResults)
					{
						<tr>
							<td>@result.Value</td>
							<td>@result.Probability</td>
							<td>@result.Encoding</td>
						</tr>
					}
				</table>
			</div>
			<h3>Mittlere Codewortlänge: @averageMessageLength bits</h3>
			<h3>Entropie: @entropy bits</h3>
		</div>
	}
}

@code {
	[Parameter]
	public bool UseShannonFano { get; set; } = true;

	private bool solved = false;
	private List<Tuple<string, int>> valuePairs = new List<Tuple<string, int>>();
	private List<EncodingDataModel> encodingResults = new List<EncodingDataModel>();

	private Encoding encoding = new();
	private string inputValuePair = "";
	private double entropy = 0;
	private double averageMessageLength = 0;

	private void Add()
	{
		string[] splitedInputPair = inputValuePair.Split(" ");

		if (splitedInputPair.Length == 2)
		{
			int amount;
			//estimated value
			if (int.TryParse(splitedInputPair[1], out amount))
			{
				valuePairs.Add(new Tuple<string, int>(splitedInputPair[0], amount));
			}
			else
			{
				Console.WriteLine("{0} is not a correct value!", splitedInputPair[1]);
			}
		}
		else
		{
			Console.WriteLine("A value pair has to be of size 2 and with space separated!");
		}

		inputValuePair = "";
	}

	private void RemoveLastPair()
	{
		if (valuePairs.Count > 0)
		{
			valuePairs.RemoveAt(valuePairs.Count - 1);
		}
	}

	private void Solve()
	{
		if (UseShannonFano)
		{
			encoding.GenerateShannonFano(valuePairs);
			//TestCase();
		}
		else
		{
			//encoding.GenerateHuffman(valuePairs);
			TestCase();
		}

		encodingResults = encoding.encodingDataModels;
		entropy = encoding.CalculateEntropy();
		averageMessageLength = encoding.CalculateAverageMessageLenght();
		solved = true;

		//TestCase();
	}

	private void Reset()
	{
		valuePairs.Clear();
		encodingResults.Clear();
		inputValuePair = "";
		entropy = 0;
		averageMessageLength = 0;
		solved = false;
	}

	private void TestCase()
	{
		List<Tuple<string, int>> testPairs = new List<Tuple<string, int>>();
		testPairs.Add(new Tuple<string, int>("PG", 1));
		testPairs.Add(new Tuple<string, int>("DH", 1));
		testPairs.Add(new Tuple<string, int>("BD", 1));
		testPairs.Add(new Tuple<string, int>("BT", 2));
		testPairs.Add(new Tuple<string, int>("B3", 3));
		testPairs.Add(new Tuple<string, int>("KAM", 3));
		testPairs.Add(new Tuple<string, int>("DW", 4));
		testPairs.Add(new Tuple<string, int>("L", 5));
		testPairs.Add(new Tuple<string, int>("BS", 6));
		testPairs.Add(new Tuple<string, int>("SB", 8));

		/*testPairs.Add(new Tuple<string, int>("A", 1));
		testPairs.Add(new Tuple<string, int>("B", 1));
		testPairs.Add(new Tuple<string, int>("C", 2));
		testPairs.Add(new Tuple<string, int>("D", 3));*/

		if (UseShannonFano)
		{
			encoding.GenerateShannonFano(testPairs);
		}
		else
		{
			encoding.GenerateHuffman(testPairs);
		}

	}
}
