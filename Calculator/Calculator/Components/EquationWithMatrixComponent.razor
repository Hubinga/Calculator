@using Calculator.Classes;
@using Calculator.Classes.Enums;
@using Calculator.Models;

@if (!active)
{
	<EditForm Model="@dimensionModel" OnValidSubmit="@Start">
		<DataAnnotationsValidator />
		<ValidationSummary />
		<div class="equation-with-matrix">
			<div class="child">
				<p>
					<label>
						Dimension:
						<InputText @bind-Value="dimensionModel.Dimension" />
					</label>
				</p>
			</div>
			<button class="button-purple" type="submit">Start</button>
		</div>
	</EditForm>
}
else
{
	<button class="button-purple" @onclick="Solve">Result</button>
	<button class="button-purple" @onclick="Reset">Reset</button>
	<button class="button-purple" @onclick="GenerateRandomInput">Random Input</button>
	<div class="equation-with-matrix">
		@{
			<div class="child">
				<MatrixComponent Matrix="matrixA" Edit="true"></MatrixComponent>
			</div>
			
			<div class="matrixWithBrackets">
				@for (int i = 0; i < matrixA.RowSize; i++)
				{
					<div class="element">x@(i+1)</div>
				}
			</diV>
			<div class="child">
				<p>=</p>
			</div>
			<div class="child">
				<MatrixComponent Matrix="vectorB" Edit="@(calculationType == CalculationTypes.EquationSystem)"></MatrixComponent>
			</div>
		}
	</div>
	@if (solved)
	{
		<div class="equation-with-matrix">
			<div class="child">
				<div class="result-left-border"></div>	
			</div>
			<div class="child">
				<MatrixComponent Matrix="matrixAResult" BracketStyle="false" Edit="false"></MatrixComponent>
			
			</div>
			<div class="child">
				<div class="result-middle-border"></div>
			</div>
			<div class="child">
				<MatrixComponent Matrix="vectorBResult" BracketStyle="false" Edit="false"></MatrixComponent>
			</div>
			<div class="child">
				<div class="result-right-border"></div>
			</div>
		</div>
	}
}


@code {
	private MatrixDimensionModel dimensionModel = new();
	private bool solved = false;
	private bool active = false;

	private Matrix matrixA = new Matrix(3, 3);
	//inhomogene vector b or I for inverse
	private Matrix vectorB = new Matrix(3, 1);

	private Matrix matrixAResult = new Matrix(3, 3);
	private Matrix vectorBResult = new Matrix(3, 1);
	private MatrixHelper matrixHelper = new();

	[Parameter]
	public CalculationTypes calculationType { get; set; } = CalculationTypes.EquationSystem;

	private void Start()
	{
		active = true;
		//start with empty matrix (n,n)-Matrix
		matrixA = new Matrix(dimensionModel.RowSize, dimensionModel.RowSize);
		matrixAResult = new Matrix(dimensionModel.RowSize, dimensionModel.RowSize);
		//vector b has to be (n,1)-Matrix if it is Ax = b or (n,n)-Matrix if it is A|I -> I|A-1
		int rows = calculationType == CalculationTypes.EquationSystem ? 1 : dimensionModel.RowSize;

		vectorB = new Matrix(dimensionModel.RowSize, rows);
		vectorBResult = new Matrix(dimensionModel.RowSize, rows);

		//make unit matrix
		if(calculationType == CalculationTypes.Inverse)
		{
			vectorB.MakeUnitMatrix();
			vectorBResult.MakeUnitMatrix();
		}

	}

	private void Reset()
	{
		active = false;
		solved = false;
	}

	private void Solve()
	{
		try
		{
			//start with copy of input matrices
			Array.Copy(matrixA.MatrixBoard, matrixAResult.MatrixBoard, matrixA.MatrixBoard.Length);
			Array.Copy(vectorB.MatrixBoard, vectorBResult.MatrixBoard, vectorB.MatrixBoard.Length);

			matrixHelper.GaußJordan(matrixAResult, vectorBResult);
			solved = true;
		}
		catch (GausJordanException e)
		{
			Console.WriteLine(e.Message);
		}
	}

	private void GenerateRandomInput()
	{
		matrixA.FillMatrixWithRandomNumbers();
		if(calculationType == CalculationTypes.EquationSystem)
		{
			vectorB.FillMatrixWithRandomNumbers();
		}
	}
}
